From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Tue, 10 Sep 2024 10:40:50 +0200
Subject: [PATCH] Optimization: WIP. Block entity limits. Reimplement in a
 better way.


diff --git a/src/main/java/abomination/BlockEntityLimiter.java b/src/main/java/abomination/BlockEntityLimiter.java
new file mode 100644
index 0000000000000000000000000000000000000000..074cff49a135ebe0abc0d82f34f57967e4d80932
--- /dev/null
+++ b/src/main/java/abomination/BlockEntityLimiter.java
@@ -0,0 +1,167 @@
+package abomination;
+
+import org.bukkit.event.block.BlockPlaceEvent;
+import org.bukkit.Chunk;
+import org.bukkit.craftbukkit.CraftChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Material;
+import net.md_5.bungee.api.ChatColor;
+import net.minecraft.world.level.block.entity.*;
+import net.minecraft.world.level.block.*;
+import net.minecraft.world.level.chunk.ChunkAccess;
+
+import abomination.config.UnsupportedWipOptionsWillChange.BlockEntityLimits;
+
+public class BlockEntityLimiter {
+
+    public static boolean limitBlockEntities(BlockPlaceEvent event) {
+        if (BlockEntityLimits.enabled == false) return true;
+
+        Material material = event.getBlock().getType();
+ 
+        boolean blockEntity = false;
+        if (material == Material.ENCHANTING_TABLE || material == Material.ENDER_CHEST || material == Material.CAMPFIRE || material == Material.SOUL_CAMPFIRE ||
+            org.bukkit.Tag.SHULKER_BOXES.getValues().contains(material) || material == Material.PLAYER_HEAD || material == Material.ZOMBIE_HEAD || material == Material.CREEPER_HEAD || material == Material.DRAGON_HEAD || material == Material.PIGLIN_HEAD ||
+            material == Material.CHEST || material == Material.TRAPPED_CHEST || material == Material.BARREL || material == Material.HOPPER || material == Material.LECTERN || material == Material.SPAWNER || material == Material.BEACON || material == Material.BREWING_STAND ||
+            material == Material.FURNACE || material == Material.BLAST_FURNACE || material == Material.SMOKER || material == Material.DROPPER || material == Material.JUKEBOX || material == Material.COMPOSTER || material == Material.BELL || org.bukkit.Tag.BANNERS.getValues().contains(material))
+            blockEntity = true;
+
+        if (!blockEntity) return true;
+ 
+        Chunk chunkBukkit = event.getBlock().getChunk();
+        CraftChunk chunkAccess = (CraftChunk)chunkBukkit;
+        ChunkAccess chunk = chunkAccess.getHandle(net.minecraft.world.level.chunk.status.ChunkStatus.FULL);
+
+        int blockEntitiesTotal = chunk.blockEntities.size();
+
+        if (blockEntitiesTotal > BlockEntityLimits.total) {
+            event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of tile entities " + (blockEntitiesTotal - 1) + "/" + BlockEntityLimits.total));
+            event.setCancelled(true);
+            return false;
+        }
+
+        int count = 0;
+        int limit = BlockEntityLimits.limitEnchantingTable;
+        if (limit > 0 && material == Material.ENCHANTING_TABLE) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof EnchantingTableBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of enchanting tables " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitCampfire;
+        if (limit > 0 && (material == Material.CAMPFIRE || material == Material.SOUL_CAMPFIRE)) {
+            for (BlockEntity ent : chunk.blockEntities.values()) {
+                if (ent instanceof CampfireBlockEntity) count++;
+            }
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of campfires " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitPlayerHead;
+        if (limit > 0 && (material == Material.PLAYER_HEAD || material == Material.ZOMBIE_HEAD || material == Material.CREEPER_HEAD || material == Material.DRAGON_HEAD || material == Material.PIGLIN_HEAD)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof SkullBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of heads " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitChest;
+        if (limit > 0 && (material == Material.CHEST || material == Material.TRAPPED_CHEST || material == Material.BARREL)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof ChestBlockEntity || ent instanceof BarrelBlockEntity || ent instanceof TrappedChestBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of chests " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitShulker;
+        if (limit > 0 && (org.bukkit.Tag.SHULKER_BOXES.getValues().contains(material))) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof ShulkerBoxBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of shulkers " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitEnderChest;
+        if (limit > 0 && (material == Material.ENDER_CHEST)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof EnderChestBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of ender chests " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitLecterns;
+        if (limit > 0 && (material == Material.LECTERN)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof LecternBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of lecterns " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitBeacon;
+        if (limit > 0 && (material == Material.BEACON)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof BeaconBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of beacons " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitBrewingStand;
+        if (limit > 0 && (material == Material.BREWING_STAND)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof BrewingStandBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of brewing stands " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitBanner;
+        if (limit > 0 && (org.bukkit.Tag.BANNERS.getValues().contains(material))) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof BannerBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of banners " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitBell;
+        if (limit > 0 && (material == Material.BELL)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof BellBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of bells " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitSpawner;
+        if (limit > 0 && (material == Material.SPAWNER)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof SpawnerBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of spawners " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/abomination/config/UnsupportedWipOptionsWillChange.java b/src/main/java/abomination/config/UnsupportedWipOptionsWillChange.java
index 692e8ae6b37008ea443dd4f7f8e6e3503d62b00b..4b9a10dd1435380b6f56ed8e3fc1317a0af97db3 100644
--- a/src/main/java/abomination/config/UnsupportedWipOptionsWillChange.java
+++ b/src/main/java/abomination/config/UnsupportedWipOptionsWillChange.java
@@ -1,4 +1,21 @@
 package abomination.config;
 
 public class UnsupportedWipOptionsWillChange {
+    public static class BlockEntityLimits {
+        public static boolean enabled = false;
+
+        public static int total = 1024;
+        public static int limitEnchantingTable = 32;
+        public static int limitCampfire = 16; // Very slow
+        public static int limitSpawner = 32;
+        public static int limitPlayerHead = 32;
+        public static int limitChest = 512;
+        public static int limitShulker = 128;
+        public static int limitEnderChest = 64;
+        public static int limitLecterns = 32;
+        public static int limitBeacon = 32;
+        public static int limitBrewingStand = 32;
+        public static int limitBanner = 32;
+        public static int limitBell = 32;
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index f2a3cb4be886bd81d795b57b97536306534c5973..5d251aba86e12603592edbe219f681cdfbf22377 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -456,7 +456,7 @@ public class CraftEventFactory {
         }
 
         BlockPlaceEvent event = new BlockPlaceEvent(placedBlock, replacedBlockState, blockClicked, item, player, canBuild, equipmentSlot);
-        craftServer.getPluginManager().callEvent(event);
+        if (abomination.BlockEntityLimiter.limitBlockEntities(event)) craftServer.getPluginManager().callEvent(event); // Abomination
 
         return event;
     }
