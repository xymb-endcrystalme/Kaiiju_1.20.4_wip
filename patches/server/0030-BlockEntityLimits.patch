From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Tue, 10 Sep 2024 10:40:50 +0200
Subject: [PATCH] BlockEntityLimits


diff --git a/src/main/java/abomination/BlockEntityLimits.java b/src/main/java/abomination/BlockEntityLimits.java
new file mode 100644
index 0000000000000000000000000000000000000000..9981b8b76ac9a4501a01f7380e3ec4a11cb8c75b
--- /dev/null
+++ b/src/main/java/abomination/BlockEntityLimits.java
@@ -0,0 +1,156 @@
+package abomination;
+
+import org.bukkit.event.block.BlockPlaceEvent;
+import org.bukkit.Chunk;
+import org.bukkit.craftbukkit.CraftChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Material;
+import net.md_5.bungee.api.ChatColor;
+import net.minecraft.block.entity.*;
+import net.minecraft.world.level.block.entity.*;
+
+public class BlockEntityLimits {
+
+    private static boolean limitTileEntities(BlockPlaceEvent event) {
+        if (KaiijuConfig.blockEntityLimitsTotal <= 0 && KaiijuConfig.blockEntityLimitsEnchantingTable <= 0 && KaiijuConfig.blockEntityLimitsCampfire <= 0 && KaiijuConfig.blockEntityLimitsSpawner <= 0 &&
+            KaiijuConfig.blockEntityLimitsPlayerHead <= 0 && KaiijuConfig.blockEntityLimitsChest <= 0 && KaiijuConfig.blockEntityLimitsShulker <= 0 && KaiijuConfig.blockEntityLimitsEnderChest <= 0 &&
+            KaiijuConfig.blockEntityLimitsLecterns <= 0 && KaiijuConfig.blockEntityLimitsBeacon <= 0 && KaiijuConfig.blockEntityLimitsBrewingStand <= 0 && KaiijuConfig.blockEntityLimitsBanner <= 0 &&
+            KaiijuConfig.blockEntityLimitsBell <= 0) return true;
+
+        Chunk chunkBukkit = event.getBlock().getChunk();
+        CraftChunk chunkAccess = (CraftChunk)chunkBukkit;
+        LevelChunk chunk = chunkAccess.getHandle();
+        Material material = event.getBlock().getType();
+
+        boolean blockEntity = false;
+        if (material == Material.ENCHANTING_TABLE || material == Material.ENDER_CHEST || material == Material.CAMPFIRE || material == Material.SOUL_CAMPFIRE ||
+            org.bukkit.Tag.SHULKER_BOXES.getValues().contains(material) || material == Material.PLAYER_HEAD || material == Material.ZOMBIE_HEAD || material == Material.CREEPER_HEAD || material == Material.DRAGON_HEAD || material == Material.PIGLIN_HEAD ||
+            material == Material.CHEST || material == Material.TRAPPED_CHEST || material == Material.BARREL || material == Material.HOPPER || material == Material.LECTERN || material == Material.SPAWNER || material == Material.BEACON || material == Material.BREWING_STAND ||
+            material == Material.FURNACE || material == Material.BLAST_FURNACE || material == Material.SMOKER /*|| material == Material.DISPENSER*/ || material == Material.DROPPER || material == Material.JUKEBOX || material == Material.COMPOSTER || material == Material.BELL || org.bukkit.Tag.BANNERS.getValues().contains(material))
+            blockEntity = true;
+
+        if (!blockEntity) return true;
+
+        int blockEntitiesTotal = chunk.getBlockEntities().size();
+
+        if (blockEntitiesTotal > KaiijuConfig.blockEntityLimitsTotal) {
+            event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of tile entities " + (blockEntitiesTotal - 1) + "/" + KaiijuConfig.blockEntityLimitsTotal));
+            event.setCancelled(true);
+            return false;
+        }
+
+        int count = 0;
+        int limit = KaiijuConfig.blockEntityLimitsEnchantingTable;
+        if (limit > 0 && material == Material.ENCHANTING_TABLE) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof EnchantmentTableBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of enchanting tables " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsCampfire;
+        if (limit > 0 && (material == Material.CAMPFIRE || material == Material.SOUL_CAMPFIRE)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values()) {
+                if (ent instanceof CampfireBlockEntity) count++;
+            }
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of campfires " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsPlayerHead;
+        if (limit > 0 && (material == Material.PLAYER_HEAD || material == Material.ZOMBIE_HEAD || material == Material.CREEPER_HEAD || material == Material.DRAGON_HEAD || material == Material.PIGLIN_HEAD)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof SkullBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of heads " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsChest;
+        if (limit > 0 && (material == Material.CHEST || material == Material.TRAPPED_CHEST || material == Material.BARREL)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof ChestBlockEntity || ent instanceof BarrelBlockEntity || ent instanceof TrappedChestBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of chests " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsShulker;
+        if (limit > 0 && (org.bukkit.Tag.SHULKER_BOXES.getValues().contains(material))) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof ShulkerBoxBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of shulkers " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsEnderChest;
+        if (limit > 0 && (material == Material.ENDER_CHEST)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof EnderChestBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of ender chests " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsLecterns;
+        if (limit > 0 && (material == Material.LECTERN)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof LecternBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of lecterns " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsBeacon;
+        if (limit > 0 && (material == Material.BEACON)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof BeaconBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of beacons " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsBrewingStand;
+        if (limit > 0 && (material == Material.BREWING_STAND)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof BrewingStandBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of brewing stands " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsBanner;
+        if (limit > 0 && (org.bukkit.Tag.BANNERS.getValues().contains(material))) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof BannerBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of banners " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = KaiijuConfig.blockEntityLimitsBell;
+        if (limit > 0 && (material == Material.BELL)) {
+            for (BlockEntity ent : chunk.getBlockEntities().values())
+                if (ent instanceof BellBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of bells " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        return true;
+    }
+}
\ No newline at end of file
