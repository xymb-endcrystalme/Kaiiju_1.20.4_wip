From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Wed, 21 Aug 2024 23:34:33 +0200
Subject: [PATCH] Exploit: Lagbook removal


diff --git a/src/main/java/abomination/PreventLagBooks.java b/src/main/java/abomination/PreventLagBooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..dae908f546ff0f443458ee5876dea08ae49e7469
--- /dev/null
+++ b/src/main/java/abomination/PreventLagBooks.java
@@ -0,0 +1,96 @@
+package abomination;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.world.level.ChunkPos;
+import org.apache.commons.lang3.tuple.Pair;
+import org.slf4j.Logger;
+import com.mojang.logging.LogUtils;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+
+public class PreventLagBooks {
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    // Counts how big are all books in the chunk and if they are above certain size, cuts them down.
+    // Doesn't iterate over contents of shulkers in chests, only free-standing containers.
+    public static void preventLagBooks(ChunkPos pos, CompoundTag nbt) {
+        if (abomination.config.Exploit.enableLagbookRemoval == false) return;
+        if (nbt == null) return;
+
+        int chunkBookSizeLimit = 1024 * 1024 * 10;
+
+        List<Pair<Integer, CompoundTag>> allBooks = new ArrayList<>();
+
+        if (nbt.contains("block_entities")) {
+            ListTag blockEntitiesNbt = nbt.getList("block_entities", 10);
+            for (int k1 = 0; k1 < blockEntitiesNbt.size(); ++k1) {
+                CompoundTag blockEntityNbt = blockEntitiesNbt.getCompound(k1);
+                if (blockEntityNbt.contains("Items")) {
+                    ListTag items = blockEntityNbt.getList("Items", 10);
+                    for (int i = 0; i < items.size(); ++i) {
+                        CompoundTag itemNbt = items.getCompound(i);
+                        searchPagesRecursively(itemNbt, allBooks);
+                    }
+                }
+            }
+        }
+        if (allBooks.size() == 0) return;
+
+        int allBooksSize = allBooks.stream().mapToInt(Pair::getLeft).sum();
+
+        if (allBooksSize > chunkBookSizeLimit) {
+            LOGGER.info("Lagbooks detected size: " + allBooksSize + " at: " + pos);
+            int removedBooks = 0;
+
+            allBooks.sort(Comparator.comparing((Pair<Integer, CompoundTag> pair) -> pair.getLeft()).reversed());
+
+            while (allBooksSize > chunkBookSizeLimit && !allBooks.isEmpty()) {
+                Pair<Integer, CompoundTag> largestBook = allBooks.remove(0);
+                allBooksSize -= largestBook.getLeft();
+                removedBooks++;
+                largestBook.getRight().remove("pages");
+            }
+            LOGGER.info("Lagbooks removed: " + removedBooks + "/" + (removedBooks + allBooks.size()));
+
+            allBooksSize = allBooks.stream().mapToInt(Pair::getLeft).sum();
+            if (allBooks.size() > 0)
+                LOGGER.info("Lagbooks final count: " + allBooks.size() + " size: " + allBooksSize);
+        }
+    }
+
+    private static void searchPagesRecursively(CompoundTag tag, List<Pair<Integer, CompoundTag>> allBooks) {
+        for (String key : tag.getAllKeys()) {
+            if (tag.get(key) instanceof CompoundTag) {
+                CompoundTag compoundTag = tag.getCompound(key);
+                if (compoundTag.contains("pages")) {
+                    addBookToList(compoundTag, allBooks);
+                }
+                searchPagesRecursively(compoundTag, allBooks);
+            } else if (tag.get(key) instanceof ListTag) {
+                ListTag listTag = tag.getList(key, 10); // 10 is the ID for CompoundTag
+                for (int i = 0; i < listTag.size(); i++) {
+                    searchPagesRecursively(listTag.getCompound(i), allBooks);
+                }
+            }
+        }
+    }
+
+    private static void addBookToList(CompoundTag itemTag, List<Pair<Integer, CompoundTag>> allBooks) {
+        if (itemTag.contains("pages")) {
+            ListTag pagesNbt = itemTag.getList("pages", 10);
+            int totalBookSize = 0;
+            for (int pageNo = 0; pageNo < pagesNbt.size(); ++pageNo) {
+                CompoundTag pageTag = pagesNbt.getCompound(pageNo);
+
+                if (pageTag != null && pageTag.contains("raw")) {
+                    String page = pageTag.getString("raw");
+                    totalBookSize += page.getBytes().length;
+                }
+            }
+            allBooks.add(Pair.of(totalBookSize, itemTag));
+        }
+    }
+}
diff --git a/src/main/java/abomination/config/Exploit.java b/src/main/java/abomination/config/Exploit.java
index 0ff1235be2ece9c90e2f5d424c105e57a73b227f..8abe8c87df1ea71470c0e2e9ee49800eea5d1d4e 100644
--- a/src/main/java/abomination/config/Exploit.java
+++ b/src/main/java/abomination/config/Exploit.java
@@ -2,4 +2,5 @@ package abomination.config;
 
 public class Exploit {
     public static boolean disableChestLocking = false; // Chest locking in Minecraft is extremely slow. Opening a double chest full of shulkers as fast as possible takes MSPT to 175 in my test.
+    public static boolean enableLagbookRemoval = false; // Count how much data is in books in freestanding containers (it won't search in shulkers in chests). If there are > 10MB, remove the biggest ones.
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index eac77c2ca9584691942b2fa591df3a2d16288aa2..a24c1627a9e2e0d4a5acaedb6c50491726bfe03c 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -346,6 +346,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
             DataOutputStream dataoutputstream = regionfile.getChunkDataOutputStream(pos);
 
             try {
+                abomination.PreventLagBooks.preventLagBooks(pos, nbt); // Abomination
                 NbtIo.write(nbt, (DataOutput) dataoutputstream);
                 regionfile.setOversized(pos.x, pos.z, false); // Paper - We don't do this anymore, mojang stores differently, but clear old meta flag if it exists to get rid of our own meta file once last oversized is gone
                 // Paper start - don't write garbage data to disk if writing serialization fails
