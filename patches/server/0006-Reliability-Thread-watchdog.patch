From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Wed, 28 Aug 2024 16:54:55 +0200
Subject: [PATCH] Reliability: Thread watchdog


diff --git a/src/main/java/abomination/ThreadStabilityWatchdog.java b/src/main/java/abomination/ThreadStabilityWatchdog.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb5b345cc50eb38279fb05128c20fd8c09f5b5a0
--- /dev/null
+++ b/src/main/java/abomination/ThreadStabilityWatchdog.java
@@ -0,0 +1,112 @@
+package abomination;
+
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool;
+import org.slf4j.Logger;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.StacktraceDeobfuscator;
+
+public class ThreadStabilityWatchdog {
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private static Thread thread;
+    private static ThreadStabilityWatchdog instance;
+
+    private static Object lock = new Object();
+    private static int[] threadStamps = new int[1];
+    private static TickThread[] threads = new TickThread[1];
+
+    private void verifyThreads() {
+        int warningDelay = abomination.config.Reliability.ThreadStabilityWatchdog.warningIntervalInSeconds;
+        if (warningDelay < 1) warningDelay = 1;
+        int length = threadStamps.length;
+        int currentTime = (int)(System.currentTimeMillis() / 100);
+        for (int i = 0 ; i < length ; i++) {
+            if (threadStamps[i] != 0 || (abomination.config.Reliability.ThreadStabilityWatchdog.justSpamMeMode && threads[i] != null)) {
+                int elapsed = currentTime - threadStamps[i];
+                if (abomination.config.Reliability.ThreadStabilityWatchdog.justSpamMeMode || elapsed > warningDelay * 10) {
+                    if (!abomination.config.Reliability.ThreadStabilityWatchdog.justSpamMeMode) threadStamps[i] = currentTime;
+                    TickThread crashedThread = threads[i];
+                    LOGGER.info("Abomination: Thread stuck - " + (elapsed / 10) + " seconds - " + crashedThread.getName());
+                    if (crashedThread != null) {
+                        StackTraceElement[] stackTrace = crashedThread.getStackTrace();
+                        stackTrace = StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(stackTrace);
+                        StringBuilder stackTraceStr = new StringBuilder("Stack trace for stuck thread:\n");
+                        for (StackTraceElement element : stackTrace) {
+                            stackTraceStr.append("\tat ").append(element.toString()).append("\n");
+                        }
+                        LOGGER.error(stackTraceStr.toString().strip());
+                    } else {
+                        LOGGER.error("Unable to retrieve stack trace for crashed thread.");
+                    }
+                    LOGGER.info("Do not contact Paper for support! Instead look for support here: https://github.com/xymb-endcrystalme/Abomination");
+                }
+            }
+        }
+    }
+
+    public ThreadStabilityWatchdog() {
+        if (thread != null) return;
+        instance = this;
+        thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                while (!Thread.currentThread().isInterrupted()) {
+                    //LOGGER.info("Thread stability watchdog tick");
+                    verifyThreads();
+                    try {
+                        int warningDelay = abomination.config.Reliability.ThreadStabilityWatchdog.warningIntervalInSeconds;
+                        if (warningDelay < 1) warningDelay = 1;
+                        if (abomination.config.Reliability.ThreadStabilityWatchdog.justSpamMeMode) Thread.sleep(1000 * warningDelay);
+                        else Thread.sleep(100);
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        });
+        thread.start();
+    }
+
+    public static void start() {
+        if (instance == null) instance = new ThreadStabilityWatchdog();
+    }
+
+    public static void markThread() {
+        Thread current = Thread.currentThread();
+        if (current instanceof TickThread thr) {
+            int id = thr.id;
+            if (threadStamps.length < id + 1) {
+                synchronized(lock) {
+                    int[] newThreadStamps = new int[id + 1];
+                    TickThread[] newThreads = new TickThread[id + 1];
+                    for (int i = 0 ; i < threadStamps.length ; i++) newThreadStamps[i] = threadStamps[i];
+                    for (int i = 0 ; i < threads.length ; i++) newThreads[i] = threads[i];
+                    threads = newThreads;
+                    threadStamps = newThreadStamps;
+                }
+            }
+            threads[id] = thr;
+            threadStamps[id] = (int)(System.currentTimeMillis() / 100);
+            if (threadStamps[id] == 0) threadStamps[id] = 1;
+        }
+    }
+
+    public static void unmarkThread() {
+        Thread current = Thread.currentThread();
+        if (current instanceof TickThread thr) {
+            int id = thr.id;
+            if (threadStamps.length > id) threadStamps[id] = 0;
+        }
+    }
+
+    public static void fullUnmarkThread() {
+        Thread current = Thread.currentThread();
+        if (current instanceof TickThread thr) {
+            int id = thr.id;
+            if (threadStamps.length > id) threadStamps[id] = 0;
+            if (threads.length > id) threads[id] = null;
+        }
+    }
+}
diff --git a/src/main/java/abomination/config/Reliability.java b/src/main/java/abomination/config/Reliability.java
index 7c92166683e9f626c5df53058369aa44ab352624..b405b7d9f2d5c5974500659d30697b979b9eb38b 100644
--- a/src/main/java/abomination/config/Reliability.java
+++ b/src/main/java/abomination/config/Reliability.java
@@ -3,4 +3,10 @@ package abomination.config;
 public class Reliability {
     public static int saveMapDataEveryXSeconds = 600; // 0 to disable
     public static boolean makeAllPluginEventsSynchronized = false; // Fixes some plugins that claim Folia compatibility, but have multithreading bugs
+
+    public static class ThreadStabilityWatchdog {
+        public static boolean enabled = true;
+        public static int warningIntervalInSeconds = 10;
+        public static boolean justSpamMeMode = false; // Just spam on every seconds
+    }
 }
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java b/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
index 8197ccb1c4e5878dbd8007b5fb514640765ec8e4..ba1ea38d534bc32fcc3e5f96cd300652a9501e9b 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
@@ -508,7 +508,9 @@ public class SchedulerThreadPool {
                 switch (startStateType) {
                     case STATE_IDLE: {
                         while (this.state.state == STATE_IDLE) {
+                            abomination.ThreadStabilityWatchdog.unmarkThread(); // Abomination
                             LockSupport.park();
+                            abomination.ThreadStabilityWatchdog.markThread(); // Abomination
                             if (this.scheduler.halted) {
                                 return;
                             }
@@ -537,6 +539,7 @@ public class SchedulerThreadPool {
                         }
 
                         // TODO exception handling
+                        abomination.ThreadStabilityWatchdog.markThread(); // Abomination
                         final boolean reschedule = startStateTask.runTick();
 
                         this.returnTask(startStateTask, reschedule);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index ac56b02498eb38883ae462be6ef3d15cb2a855aa..d4eff6e31f28266aa487396d0058a8b6188a312d 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1277,6 +1277,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     protected void runServer() {
         try {
+            abomination.ThreadStabilityWatchdog.markThread(); // Abomination
             long serverStartTime = Util.getNanos(); // Paper
             if (!this.initServer()) {
                 throw new IllegalStateException("Failed to initialize server");
@@ -1291,6 +1292,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 io.papermc.paper.threadedregions.RegionizedServer.getInstance().init(); // Folia - region threading - only after loading worlds
                 String doneTime = String.format(java.util.Locale.ROOT, "%.3fs", (double) (Util.getNanos() - serverStartTime) / 1.0E9D);
                 LOGGER.info("Done ({})! For help, type \"help\"", doneTime);
+                abomination.ThreadStabilityWatchdog.fullUnmarkThread(); // Abomination
                 for (;;) {
                     try {
                         Thread.sleep(Long.MAX_VALUE);
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index b35a5c9e45dcc61ee7415f2b7650cdcfd37f1ff6..c1d997a28fc4e8ba50c44764ab5e634300a9b734 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -317,6 +317,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         }
 
         if (abomination.config.Reliability.saveMapDataEveryXSeconds > 0) abomination.MapSaverThread.start(); // Abomination
+        abomination.ThreadStabilityWatchdog.start(); // Abomination
 
         if (!OldUsersConverter.serverReadyAfterUserconversion(this)) {
             return false;
