From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Tue, 10 Sep 2024 14:25:22 +0200
Subject: [PATCH] BlockEntityLimits


diff --git a/src/main/java/abomination/BlockEntityLimiter.java b/src/main/java/abomination/BlockEntityLimiter.java
index ba31553ee3a50a06b96eaa743e1296fde9b4e16c..074cff49a135ebe0abc0d82f34f57967e4d80932 100644
--- a/src/main/java/abomination/BlockEntityLimiter.java
+++ b/src/main/java/abomination/BlockEntityLimiter.java
@@ -18,7 +18,7 @@ public class BlockEntityLimiter {
         if (BlockEntityLimits.enabled == false) return true;
 
         Material material = event.getBlock().getType();
-
+ 
         boolean blockEntity = false;
         if (material == Material.ENCHANTING_TABLE || material == Material.ENDER_CHEST || material == Material.CAMPFIRE || material == Material.SOUL_CAMPFIRE ||
             org.bukkit.Tag.SHULKER_BOXES.getValues().contains(material) || material == Material.PLAYER_HEAD || material == Material.ZOMBIE_HEAD || material == Material.CREEPER_HEAD || material == Material.DRAGON_HEAD || material == Material.PIGLIN_HEAD ||
@@ -27,7 +27,7 @@ public class BlockEntityLimiter {
             blockEntity = true;
 
         if (!blockEntity) return true;
-
+ 
         Chunk chunkBukkit = event.getBlock().getChunk();
         CraftChunk chunkAccess = (CraftChunk)chunkBukkit;
         ChunkAccess chunk = chunkAccess.getHandle(net.minecraft.world.level.chunk.status.ChunkStatus.FULL);
@@ -35,7 +35,7 @@ public class BlockEntityLimiter {
         int blockEntitiesTotal = chunk.blockEntities.size();
 
         if (blockEntitiesTotal > BlockEntityLimits.total) {
-            event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of tile entities " + (blockEntitiesTotal - 1) + "/" + BlockEntityLimits.total));
+            event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of tile entities " + (blockEntitiesTotal - 1) + "/" + BlockEntityLimits.total));
             event.setCancelled(true);
             return false;
         }
@@ -46,7 +46,7 @@ public class BlockEntityLimiter {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof EnchantingTableBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of enchanting tables " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of enchanting tables " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
@@ -57,103 +57,111 @@ public class BlockEntityLimiter {
                 if (ent instanceof CampfireBlockEntity) count++;
             }
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of campfires " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of campfires " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        return true;
-/*
-        limit = KaiijuConfig.blockEntityLimitsPlayerHead;
+        limit = BlockEntityLimits.limitPlayerHead;
         if (limit > 0 && (material == Material.PLAYER_HEAD || material == Material.ZOMBIE_HEAD || material == Material.CREEPER_HEAD || material == Material.DRAGON_HEAD || material == Material.PIGLIN_HEAD)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof SkullBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of heads " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of heads " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsChest;
+        limit = BlockEntityLimits.limitChest;
         if (limit > 0 && (material == Material.CHEST || material == Material.TRAPPED_CHEST || material == Material.BARREL)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof ChestBlockEntity || ent instanceof BarrelBlockEntity || ent instanceof TrappedChestBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of chests " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of chests " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsShulker;
+        limit = BlockEntityLimits.limitShulker;
         if (limit > 0 && (org.bukkit.Tag.SHULKER_BOXES.getValues().contains(material))) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof ShulkerBoxBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of shulkers " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of shulkers " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsEnderChest;
+        limit = BlockEntityLimits.limitEnderChest;
         if (limit > 0 && (material == Material.ENDER_CHEST)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof EnderChestBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of ender chests " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of ender chests " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsLecterns;
+        limit = BlockEntityLimits.limitLecterns;
         if (limit > 0 && (material == Material.LECTERN)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof LecternBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of lecterns " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of lecterns " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsBeacon;
+        limit = BlockEntityLimits.limitBeacon;
         if (limit > 0 && (material == Material.BEACON)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof BeaconBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of beacons " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of beacons " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsBrewingStand;
+        limit = BlockEntityLimits.limitBrewingStand;
         if (limit > 0 && (material == Material.BREWING_STAND)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof BrewingStandBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of brewing stands " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of brewing stands " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsBanner;
+        limit = BlockEntityLimits.limitBanner;
         if (limit > 0 && (org.bukkit.Tag.BANNERS.getValues().contains(material))) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof BannerBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of banners " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of banners " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        limit = KaiijuConfig.blockEntityLimitsBell;
+        limit = BlockEntityLimits.limitBell;
         if (limit > 0 && (material == Material.BELL)) {
             for (BlockEntity ent : chunk.blockEntities.values())
                 if (ent instanceof BellBlockEntity) count++;
             if (count > limit) {
-                event.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&', "Reached the limit of bells " + (count - 1) + "/" + limit));
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of bells " + (count - 1) + "/" + limit));
+                event.setCancelled(true);
+                return false;
+            }
+        }
+        limit = BlockEntityLimits.limitSpawner;
+        if (limit > 0 && (material == Material.SPAWNER)) {
+            for (BlockEntity ent : chunk.blockEntities.values())
+                if (ent instanceof SpawnerBlockEntity) count++;
+            if (count > limit) {
+                event.getPlayer().sendActionBar(ChatColor.translateAlternateColorCodes('&', "&cReached the chunk limit of spawners " + (count - 1) + "/" + limit));
                 event.setCancelled(true);
                 return false;
             }
         }
-        return true;*/
+        return true;
     }
 }
\ No newline at end of file
